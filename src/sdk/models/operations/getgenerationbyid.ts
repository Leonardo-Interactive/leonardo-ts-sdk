/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../../lib/primitives.js";
import { safeParse } from "../../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as shared from "../shared/index.js";

export type GetGenerationByIdRequest = {
  /**
   * The ID of the generation to return.
   */
  id: string;
};

/**
 * columns and relationships of "generated_image_variation_generic"
 */
export type GetGenerationByIdGeneratedImageVariationGeneric = {
  id?: string | null | undefined;
  /**
   * The status of the current task.
   */
  status?: shared.JobStatus | undefined;
  /**
   * The type of variation.
   */
  transformType?: shared.VariationType | undefined;
  url?: string | null | undefined;
};

/**
 * columns and relationships of "generated_images"
 */
export type GeneratedImages = {
  /**
   * If fantasyAvatar feature was used.
   */
  fantasyAvatar?: boolean | null | undefined;
  generatedImageVariationGenerics?:
    | Array<GetGenerationByIdGeneratedImageVariationGeneric>
    | undefined;
  id?: string | null | undefined;
  /**
   * If it is an image to video generation.
   */
  imageToVideo?: boolean | null | undefined;
  likeCount?: number | undefined;
  /**
   * If generation is of motion type.
   */
  motion?: boolean | null | undefined;
  /**
   * The URL of the motion MP4.
   */
  motionMp4URL?: string | null | undefined;
  /**
   * The name of the motion model.
   */
  motionModel?: string | null | undefined;
  /**
   * The motion strength.
   */
  motionStrength?: number | null | undefined;
  nsfw?: boolean | undefined;
  url?: string | undefined;
};

/**
 * Element used for the generation.
 */
export type GetGenerationByIdLoras = {
  /**
   * Unique identifier for the element. Elements can be found from the List Elements endpoint.
   */
  akUUID?: string | null | undefined;
  /**
   * The base version of stable diffusion to use if not using a custom model. v1_5 is 1.5, v2 is 2.1, if not specified it will default to v1_5. Also includes SDXL and SDXL Lightning models
   */
  baseModel?: shared.SdVersions | undefined;
  /**
   * Description for the element
   */
  description?: string | null | undefined;
  /**
   * Name of the element
   */
  name?: string | null | undefined;
  /**
   * URL of the element image
   */
  urlImage?: string | null | undefined;
  /**
   * Default weight for the element
   */
  weightDefault?: number | null | undefined;
  /**
   * Maximum weight for the element
   */
  weightMax?: number | null | undefined;
  /**
   * Minimum weight for the element
   */
  weightMin?: number | null | undefined;
};

/**
 * This table captures the elements that are applied to Generations.
 */
export type GenerationElements = {
  id?: number | null | undefined;
  /**
   * Element used for the generation.
   */
  lora?: GetGenerationByIdLoras | null | undefined;
  weightApplied?: number | null | undefined;
};

/**
 * columns and relationships of "generations"
 */
export type GetGenerationByIdGenerations = {
  createdAt?: string | undefined;
  generatedImages?: Array<GeneratedImages> | undefined;
  generationElements?: Array<GenerationElements> | undefined;
  guidanceScale?: number | null | undefined;
  id?: string | null | undefined;
  imageHeight?: number | undefined;
  imageWidth?: number | undefined;
  inferenceSteps?: number | null | undefined;
  initStrength?: number | null | undefined;
  modelId?: string | null | undefined;
  negativePrompt?: string | null | undefined;
  /**
   * If photoReal feature was used.
   */
  photoReal?: boolean | null | undefined;
  /**
   * Depth of field of photoReal used. 0.55 is low, 0.5 is medium, and 0.45 is high. Default is 0.55.
   */
  photoRealStrength?: number | null | undefined;
  /**
   * The style to generate images with. When photoReal is enabled, refer to the Guide section for a full list. When alchemy is disabled, use LEONARDO or NONE. When alchemy is enabled, use ANIME, CREATIVE, DYNAMIC, ENVIRONMENT, GENERAL, ILLUSTRATION, PHOTOGRAPHY, RAYTRACED, RENDER_3D, SKETCH_BW, SKETCH_COLOR, or NONE.
   */
  presetStyle?: shared.SdGenerationStyle | null | undefined;
  prompt?: string | undefined;
  /**
   * If prompt magic was used.
   */
  promptMagic?: boolean | null | undefined;
  /**
   * Strength of prompt magic used.
   */
  promptMagicStrength?: number | null | undefined;
  /**
   * Version of prompt magic used.
   */
  promptMagicVersion?: string | null | undefined;
  public?: boolean | undefined;
  /**
   * The scheduler to generate images with. Defaults to EULER_DISCRETE if not specified.
   */
  scheduler?: shared.SdGenerationSchedulers | undefined;
  /**
   * The base version of stable diffusion to use if not using a custom model. v1_5 is 1.5, v2 is 2.1, if not specified it will default to v1_5. Also includes SDXL and SDXL Lightning models
   */
  sdVersion?: shared.SdVersions | undefined;
  /**
   * Apply a fixed seed to maintain consistency across generation sets. The maximum seed value is 2147483637 for Flux and 9999999998 for other models
   */
  seed?: number | null | undefined;
  /**
   * The status of the current task.
   */
  status?: shared.JobStatus | undefined;
  /**
   * If ultra generation mode was used.
   */
  ultra?: boolean | null | undefined;
};

/**
 * Responses for GET /generations/{id}
 */
export type GetGenerationByIdResponseBody = {
  /**
   * columns and relationships of "generations"
   */
  generationsByPk?: GetGenerationByIdGenerations | null | undefined;
};

export type GetGenerationByIdResponse = {
  /**
   * HTTP response content type for this operation
   */
  contentType: string;
  /**
   * HTTP response status code for this operation
   */
  statusCode: number;
  /**
   * Raw HTTP response; suitable for custom response parsing
   */
  rawResponse: Response;
  /**
   * Responses for GET /generations/{id}
   */
  object?: GetGenerationByIdResponseBody | undefined;
};

/** @internal */
export type GetGenerationByIdRequest$Outbound = {
  id: string;
};

/** @internal */
export const GetGenerationByIdRequest$outboundSchema: z.ZodType<
  GetGenerationByIdRequest$Outbound,
  z.ZodTypeDef,
  GetGenerationByIdRequest
> = z.object({
  id: z.string(),
});

export function getGenerationByIdRequestToJSON(
  getGenerationByIdRequest: GetGenerationByIdRequest,
): string {
  return JSON.stringify(
    GetGenerationByIdRequest$outboundSchema.parse(getGenerationByIdRequest),
  );
}

/** @internal */
export const GetGenerationByIdGeneratedImageVariationGeneric$inboundSchema:
  z.ZodType<
    GetGenerationByIdGeneratedImageVariationGeneric,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.nullable(z.string()).optional(),
    status: shared.JobStatus$inboundSchema.optional(),
    transformType: shared.VariationType$inboundSchema.optional(),
    url: z.nullable(z.string()).optional(),
  });

export function getGenerationByIdGeneratedImageVariationGenericFromJSON(
  jsonString: string,
): SafeParseResult<
  GetGenerationByIdGeneratedImageVariationGeneric,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetGenerationByIdGeneratedImageVariationGeneric$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetGenerationByIdGeneratedImageVariationGeneric' from JSON`,
  );
}

/** @internal */
export const GeneratedImages$inboundSchema: z.ZodType<
  GeneratedImages,
  z.ZodTypeDef,
  unknown
> = z.object({
  fantasyAvatar: z.nullable(z.boolean()).optional(),
  generated_image_variation_generics: z.array(
    z.lazy(() => GetGenerationByIdGeneratedImageVariationGeneric$inboundSchema),
  ).optional(),
  id: z.nullable(z.string()).optional(),
  imageToVideo: z.nullable(z.boolean()).optional(),
  likeCount: z.number().int().optional(),
  motion: z.nullable(z.boolean()).optional(),
  motionMP4URL: z.nullable(z.string()).optional(),
  motionModel: z.nullable(z.string()).optional(),
  motionStrength: z.nullable(z.number().int()).optional(),
  nsfw: z.boolean().optional(),
  url: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "generated_image_variation_generics": "generatedImageVariationGenerics",
    "motionMP4URL": "motionMp4URL",
  });
});

export function generatedImagesFromJSON(
  jsonString: string,
): SafeParseResult<GeneratedImages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GeneratedImages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GeneratedImages' from JSON`,
  );
}

/** @internal */
export const GetGenerationByIdLoras$inboundSchema: z.ZodType<
  GetGenerationByIdLoras,
  z.ZodTypeDef,
  unknown
> = z.object({
  akUUID: z.nullable(z.string()).optional(),
  baseModel: shared.SdVersions$inboundSchema.optional(),
  description: z.nullable(z.string()).optional(),
  name: z.nullable(z.string()).optional(),
  urlImage: z.nullable(z.string()).optional(),
  weightDefault: z.nullable(z.number().int()).optional(),
  weightMax: z.nullable(z.number().int()).optional(),
  weightMin: z.nullable(z.number().int()).optional(),
});

export function getGenerationByIdLorasFromJSON(
  jsonString: string,
): SafeParseResult<GetGenerationByIdLoras, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetGenerationByIdLoras$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetGenerationByIdLoras' from JSON`,
  );
}

/** @internal */
export const GenerationElements$inboundSchema: z.ZodType<
  GenerationElements,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.nullable(z.number().int()).optional(),
  lora: z.nullable(z.lazy(() => GetGenerationByIdLoras$inboundSchema))
    .optional(),
  weightApplied: z.nullable(z.number()).optional(),
});

export function generationElementsFromJSON(
  jsonString: string,
): SafeParseResult<GenerationElements, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerationElements$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerationElements' from JSON`,
  );
}

/** @internal */
export const GetGenerationByIdGenerations$inboundSchema: z.ZodType<
  GetGenerationByIdGenerations,
  z.ZodTypeDef,
  unknown
> = z.object({
  createdAt: z.string().optional(),
  generated_images: z.array(z.lazy(() => GeneratedImages$inboundSchema))
    .optional(),
  generation_elements: z.array(z.lazy(() => GenerationElements$inboundSchema))
    .optional(),
  guidanceScale: z.nullable(z.number()).optional(),
  id: z.nullable(z.string()).optional(),
  imageHeight: z.number().int().optional(),
  imageWidth: z.number().int().optional(),
  inferenceSteps: z.nullable(z.number().int()).optional(),
  initStrength: z.nullable(z.number()).optional(),
  modelId: z.nullable(z.string()).optional(),
  negativePrompt: z.nullable(z.string()).optional(),
  photoReal: z.nullable(z.boolean()).optional(),
  photoRealStrength: z.nullable(z.number()).optional(),
  presetStyle: z.nullable(
    shared.SdGenerationStyle$inboundSchema.default(
      shared.SdGenerationStyle.Dynamic,
    ),
  ),
  prompt: z.string().optional(),
  promptMagic: z.nullable(z.boolean()).optional(),
  promptMagicStrength: z.nullable(z.number()).optional(),
  promptMagicVersion: z.nullable(z.string()).optional(),
  public: z.boolean().optional(),
  scheduler: shared.SdGenerationSchedulers$inboundSchema.optional(),
  sdVersion: shared.SdVersions$inboundSchema.optional(),
  seed: z.nullable(z.number().int()).optional(),
  status: shared.JobStatus$inboundSchema.optional(),
  ultra: z.nullable(z.boolean()).optional(),
}).transform((v) => {
  return remap$(v, {
    "generated_images": "generatedImages",
    "generation_elements": "generationElements",
  });
});

export function getGenerationByIdGenerationsFromJSON(
  jsonString: string,
): SafeParseResult<GetGenerationByIdGenerations, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetGenerationByIdGenerations$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetGenerationByIdGenerations' from JSON`,
  );
}

/** @internal */
export const GetGenerationByIdResponseBody$inboundSchema: z.ZodType<
  GetGenerationByIdResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  generations_by_pk: z.nullable(
    z.lazy(() => GetGenerationByIdGenerations$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "generations_by_pk": "generationsByPk",
  });
});

export function getGenerationByIdResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetGenerationByIdResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetGenerationByIdResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetGenerationByIdResponseBody' from JSON`,
  );
}

/** @internal */
export const GetGenerationByIdResponse$inboundSchema: z.ZodType<
  GetGenerationByIdResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  ContentType: z.string(),
  StatusCode: z.number().int(),
  RawResponse: z.instanceof(Response),
  object: z.lazy(() => GetGenerationByIdResponseBody$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "ContentType": "contentType",
    "StatusCode": "statusCode",
    "RawResponse": "rawResponse",
  });
});

export function getGenerationByIdResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetGenerationByIdResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetGenerationByIdResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetGenerationByIdResponse' from JSON`,
  );
}
