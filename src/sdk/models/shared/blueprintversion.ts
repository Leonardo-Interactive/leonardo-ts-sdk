/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type Reasons = {
  models?: string | undefined;
};

export type Executability = {
  isExecutable?: boolean | undefined;
  reasons?: Array<Reasons> | undefined;
};

export type Inputs = {};

export type Outputs = {};

export type UiMetadata = {
  inputs?: Array<Inputs> | undefined;
  outputs?: Array<Outputs> | undefined;
};

export type Node = {
  akUUID?: string | undefined;
  cost?: number | undefined;
  createdAt?: Date | undefined;
  executability?: Executability | undefined;
  models?: Array<string> | undefined;
  uiMetadata?: UiMetadata | undefined;
  uiMetadataSchemaVersion?: string | undefined;
  updatedAt?: Date | undefined;
};

export type Edges = {
  cursor?: string | undefined;
  node?: Node | undefined;
};

export type BlueprintVersionPageInfo = {
  endCursor?: string | undefined;
  hasNextPage?: boolean | undefined;
  hasPreviousPage?: boolean | undefined;
  startCursor?: string | undefined;
};

/**
 * A Blueprint Version object
 */
export type BlueprintVersion = {
  edges?: Array<Edges> | undefined;
  pageInfo?: BlueprintVersionPageInfo | undefined;
  totalCount?: number | undefined;
};

/** @internal */
export const Reasons$inboundSchema: z.ZodType<Reasons, z.ZodTypeDef, unknown> =
  z.object({
    models: z.string().optional(),
  });

export function reasonsFromJSON(
  jsonString: string,
): SafeParseResult<Reasons, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Reasons$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Reasons' from JSON`,
  );
}

/** @internal */
export const Executability$inboundSchema: z.ZodType<
  Executability,
  z.ZodTypeDef,
  unknown
> = z.object({
  isExecutable: z.boolean().optional(),
  reasons: z.array(z.lazy(() => Reasons$inboundSchema)).optional(),
});

export function executabilityFromJSON(
  jsonString: string,
): SafeParseResult<Executability, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Executability$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Executability' from JSON`,
  );
}

/** @internal */
export const Inputs$inboundSchema: z.ZodType<Inputs, z.ZodTypeDef, unknown> = z
  .object({});

export function inputsFromJSON(
  jsonString: string,
): SafeParseResult<Inputs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Inputs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Inputs' from JSON`,
  );
}

/** @internal */
export const Outputs$inboundSchema: z.ZodType<Outputs, z.ZodTypeDef, unknown> =
  z.object({});

export function outputsFromJSON(
  jsonString: string,
): SafeParseResult<Outputs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Outputs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Outputs' from JSON`,
  );
}

/** @internal */
export const UiMetadata$inboundSchema: z.ZodType<
  UiMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  inputs: z.array(z.lazy(() => Inputs$inboundSchema)).optional(),
  outputs: z.array(z.lazy(() => Outputs$inboundSchema)).optional(),
});

export function uiMetadataFromJSON(
  jsonString: string,
): SafeParseResult<UiMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UiMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UiMetadata' from JSON`,
  );
}

/** @internal */
export const Node$inboundSchema: z.ZodType<Node, z.ZodTypeDef, unknown> = z
  .object({
    akUUID: z.string().optional(),
    cost: z.number().int().optional(),
    createdAt: z.string().datetime({ offset: true }).transform(v => new Date(v))
      .optional(),
    executability: z.lazy(() => Executability$inboundSchema).optional(),
    models: z.array(z.string()).optional(),
    uiMetadata: z.lazy(() => UiMetadata$inboundSchema).optional(),
    uiMetadataSchemaVersion: z.string().optional(),
    updatedAt: z.string().datetime({ offset: true }).transform(v => new Date(v))
      .optional(),
  });

export function nodeFromJSON(
  jsonString: string,
): SafeParseResult<Node, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Node$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Node' from JSON`,
  );
}

/** @internal */
export const Edges$inboundSchema: z.ZodType<Edges, z.ZodTypeDef, unknown> = z
  .object({
    cursor: z.string().optional(),
    node: z.lazy(() => Node$inboundSchema).optional(),
  });

export function edgesFromJSON(
  jsonString: string,
): SafeParseResult<Edges, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Edges$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Edges' from JSON`,
  );
}

/** @internal */
export const BlueprintVersionPageInfo$inboundSchema: z.ZodType<
  BlueprintVersionPageInfo,
  z.ZodTypeDef,
  unknown
> = z.object({
  endCursor: z.string().optional(),
  hasNextPage: z.boolean().optional(),
  hasPreviousPage: z.boolean().optional(),
  startCursor: z.string().optional(),
});

export function blueprintVersionPageInfoFromJSON(
  jsonString: string,
): SafeParseResult<BlueprintVersionPageInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BlueprintVersionPageInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BlueprintVersionPageInfo' from JSON`,
  );
}

/** @internal */
export const BlueprintVersion$inboundSchema: z.ZodType<
  BlueprintVersion,
  z.ZodTypeDef,
  unknown
> = z.object({
  edges: z.array(z.lazy(() => Edges$inboundSchema)).optional(),
  pageInfo: z.lazy(() => BlueprintVersionPageInfo$inboundSchema).optional(),
  totalCount: z.number().int().optional(),
});

export function blueprintVersionFromJSON(
  jsonString: string,
): SafeParseResult<BlueprintVersion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BlueprintVersion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BlueprintVersion' from JSON`,
  );
}
